### Дву суммы
####  1. Условие задачи

Ссылка на задачу [leet code](https://leetcode.com/problems/two-sum/) 

Дан массив целых чисел `nums` и целое число `target`, верните индексы двух чисел так, чтобы они в сумме составляли `target`.

Вы можете предположить, что каждый вход будет иметь ___ровно одно решение___ и вы не можете использовать один и тот же элемент дважды.

Вы можете вернуть ответ в любом порядке.

__Пример 1__:

```
Вход: nums = [2,7,11,15], target = 9
Выход: [0,1]
Выход: Поскольку nums[0] + nums[1] == 9, возвращаем [0, 1].
```

__Пример 2__:

```
Вход: nums = [3,2,4], target = 6
Выход: [1,2]
```
__Пример 3__:

```
Вход: nums = [3,3], target = 6
Выход: [0,1]
```
Ограничения:

-`2 <= nums.length <= 10^4`

-`10^9 <= nums[i] <= 10^9`

-`10^9 <= target <= 10^9`

-`Существует только один правильный ответ.`


__Дополнительно__: Можете ли вы придумать алгоритм, сложность которого меньше O(n<sup>2</sup>) по времени?

#### 2. Решение алгоритма two sum 

1. 


https://user-images.githubusercontent.com/38985170/218475295-a6a9e2c7-1a13-4723-a3af-d4c10dd6078b.mp4

#### 4. Анализ алгоритма

Введем для нашего алгоритма временную стоимость каждой инструкции и количество их повторений.  

|  №  |                 Инструкция                  | Стоимость |         Повторы         |
|:---:|:-------------------------------------------:|:---------:|:-----------------------:|
|     |        `int[] answers = new int[2];`        |    c0     |            1            |
|     |      `for(int i; i<nums.length; i++)`       |    c1     |            n            |
|     | `for (int j = i + 1; j < nums.length; j++)` |    с2     |  $$\sum_{i=1}^n t_j$$   |
|     |     `if (nums[i] + nums[j] == target)`      |    с3     | $$\sum_{i=1}^n t_j-1$$  |
|     |              `answers[0] = i`               |    с4     | $$\sum_{i=1}^n t_j-1$$  |
|     |              `answers[1] = j`               |    с5     | $$\sum_{i=1}^n t_j-1$$  |

t<sub>j</sub> - количество проверок условия внутреннего цикла, которое равно n-i на каждой итерации внешнего цикла.

Поскольку проверка выполнения условия выполняется на 1 раз больше чем действия внутри внутреннего цикла, то количество операций будет внутри цикла будет t<sub>j</sub>-1

Из формулы суммы арифметической прогрессии имеем:
$$\sum_{i=1}^n t_j = {n(n+1)\over2}$$
тогда
$$\sum_{i=1}^n t_j-1 = {n(n-1)\over2}$$$$ 

Таким образом общее время работы алгоритма равно:
с0 + с1n + c2 $${(n(n+1)\over2}$$ + c3 $${(n(n-1)\over2}$$ + c4 $${(n(n-1)\over2}$$ + c5$${(n(n-1)\over2}$$ = $$\left( {c2\over2}$$ + {c3\over2} + {c4\over2} + {c5\over2} \right) n^2 + \left( c1 + {c2\over2}$$ - {c3\over2} - {c4\over2} - {c5\over2} \right) n +  c0 $$ 

Это время можно записать в виде $$an^2 + bn + c$$

Таким образом, порядок роста функции асимптотически равен 